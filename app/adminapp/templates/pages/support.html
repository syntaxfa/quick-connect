{{define "support_page"}}
<div class="support-content">

  <div class="users-header"> <div class="header-left">
    <h1 class="page-title">Support Center</h1>
    <p class="page-subtitle">Manage customer conversations</p>
  </div>
  </div>

  <div class="users-stats"> <div class="stat-card">
    <div class="stat-card-icon new"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193l-15.4 1.093c-1.133.08-2.1-.84-2.1-1.973V10.608c0-.97 0.616-1.813 1.5-2.097L16.5 3.793c.884-.284 1.803 0.182 2.121 1.003l1.629 5.714z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 3.793l-1.629 5.714M18.75 5.25h-1.5" />
    </svg>
    </div>
    <div class="stat-card-content">
      <span class="stat-value">{{if .TotalNewConversations}}{{.TotalNewConversations}}{{else}}0{{end}}</span>
      <span class="stat-label">New Conversations</span>
    </div>
  </div>
  </div>

  <div class="support-tabs"
       hx-target="#support-list-container"
       hx-swap="innerHTML"
       style="margin-bottom: 2rem;">

    <button class="support-tab active"
            hx-get="/support/list/new"
            hx-trigger="click"
            onclick="switchSupportTab(this)">
      New ({{.TotalNewConversations}})
    </button>

    <button class="support-tab"
            id="my-conversations-tab-btn" onclick="switchSupportTab(this)"> My Conversations
    </button>
  </div>

  <form class="users-filters"
        id="my-conversations-filters"
        style="display: none;"
        hx-get="/support/list/my"
        hx-target="#support-list-container"
        hx-swap="innerHTML"
        hx-trigger="submit, change from:#conv-sort-select, change from:.status-filter-checkbox, click from:#my-conversations-tab-btn" >

    <select class="sort-select" name="sort_direction" id="conv-sort-select">
      <option value="2" selected>Newest First (DESC)</option>
      <option value="1">Oldest First (ASC)</option>
    </select>

    <div class="filter-dropdown">
      <button type="button" class="filter-btn" onclick="toggleRoleFilter(this)">
        <span>Filter by Status</span>
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width: 1rem; height: 1rem; margin-left: 0.5rem;">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
        </svg>
      </button>
      <div class="filter-dropdown-content">
        <label class="role-checkbox" for="filter-status-open">
          <input
                  type="checkbox"
                  name="statuses"
                  id="filter-status-open"
                  class="status-filter-checkbox"
                  value="open"
                  checked
          >
          Open
        </label>
        {{range .AllStatuses}}
        {{if ne .Value "open"}} <label class="role-checkbox" for="filter-status-{{.Value}}">
        <input
                type="checkbox"
                name="statuses"
                id="filter-status-{{.Value}}"
                class="status-filter-checkbox"
                value="{{.Value}}"
        >
        {{.Name}}
      </label>
        {{end}}
        {{end}}
      </div>
    </div>
    <button type="submit" style="display: none;">Search</button>
  </form>

  <div id="support-list-container"
       hx-get="/support/list/new"
       hx-trigger="load, conversationListChanged from:body"
       hx-swap="innerHTML">

    <div style="display: flex; justify-content: center; padding: 4rem;">
      <span style="color: #94a3b8; font-size: 1rem; font-family: 'JetBrains Mono', monospace;">Loading new conversations...</span>
    </div>
  </div>

  <div id="ws-status" style="position: fixed; bottom: 10px; left: 10px; z-index: 9999;"></div>

</div>

<script>
  /**
   * Support Chat Manager
   * Manages WebSocket connection, Chat Interaction, and Infinite Scroll History.
   */
  window.SupportChat = {
    ws: null,
    token: "{{.WebSocketToken}}",
    url: "{{.ChatWsURL}}",
    activeConversationId: null,
    reconnectInterval: 3000,
    heartbeatInterval: null,

    // History State
    nextCursor: null,
    hasMore: false,
    isLoadingHistory: false,

    init: function() {
      if (!this.token) {
        console.error("WebSocket Token is missing.");
        return;
      }

      if (this.ws) {
        this.ws.close();
      }

      this.connect();

      document.body.addEventListener('htmx:afterSwap', (evt) => {
        const targetId = evt.target.id;
        const targetTag = evt.target.tagName;

        if (targetId === 'modal-container' || targetId === 'modal-backdrop' || targetTag === 'BODY') {
          const modal = document.querySelector('.chat-modal');
          if (modal) {
            this.initModalListeners(modal);
          }
        }
      });
    },

    connect: function() {
      if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) return;

      console.log("Connecting to Chat WS:", this.url);

      try {
        this.ws = new WebSocket(this.url, [this.token]);
      } catch (e) {
        console.error("WS Create Error:", e);
        return;
      }

      this.ws.onopen = () => {
        console.log("âœ… Chat WebSocket Connected");
        this.showStatus("Connected", "success");
        this.startHeartbeat();
      };

      this.ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          this.handleIncomingMessage(msg);
        } catch (e) {
          console.error("WS Parse Error:", e);
        }
      };

      this.ws.onclose = () => {
        console.warn("Chat WebSocket Disconnected");
        this.showStatus("Disconnected. Reconnecting...", "error");
        this.stopHeartbeat();
        setTimeout(() => this.connect(), this.reconnectInterval);
      };

      this.ws.onerror = (err) => {
        console.error("WebSocket Error:", err);
      };
    },

    initModalListeners: function(modal) {
      const closeBtn = modal.querySelector('button[hx-post*="/close"]');
      const startBtn = modal.querySelector('button[hx-post*="/start"]');
      let convId = null;
      if (closeBtn) {
        convId = closeBtn.getAttribute('hx-post').split('/')[3];
      } else if (startBtn) {
        convId = startBtn.getAttribute('hx-post').split('/')[3];
      }

      const container = document.getElementById('chat-messages-container');
      if (container) {
        // Prevent browser scroll anchoring interference
        container.style.overflowAnchor = 'none';

        const newCursor = container.getAttribute('data-next-cursor');
        if (newCursor) this.nextCursor = newCursor;

        this.hasMore = container.getAttribute('data-has-more') === 'true';
        this.isLoadingHistory = false;

        modal.querySelectorAll('.msg-time-server').forEach(el => {
          const seconds = parseInt(el.getAttribute('data-ts'));
          if (seconds) {
            try {
              const date = new Date(seconds * 1000);
              el.textContent = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              el.classList.remove('msg-time-server');
            } catch(e) {}
          }
        });

        // === Scroll Listener for History ===
        container.onscroll = () => {
          // In column-reverse: 0 is Bottom.
          // We need to fetch when we are FAR from 0 (at the Top).
          const distanceFromBottom = Math.abs(container.scrollTop);
          const maxScroll = container.scrollHeight - container.clientHeight;

          // Buffer of 50px to trigger before hitting the hard edge
          if (distanceFromBottom >= (maxScroll - 50) && this.hasMore && !this.isLoadingHistory) {
            this.fetchHistory(convId);
          }
        };
      }

      if (convId) {
        this.activeConversationId = convId;

        const input = document.getElementById('chat-input');
        const sendBtn = document.getElementById('chat-send-btn');

        if (input && sendBtn) {
          input.disabled = false;
          if (document.activeElement !== input) {
            input.focus();
          }

          input.oninput = () => this.sendTyping(convId);
          input.onkeydown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              this.sendMessage(convId, input.value);
              input.value = '';
            }
          };
          sendBtn.onclick = () => {
            this.sendMessage(convId, input.value);
            input.value = '';
          };
        }
      }
    },

    fetchHistory: function(conversationId) {
      if (this.isLoadingHistory || !this.hasMore || !this.nextCursor) return;

      this.isLoadingHistory = true;

      const container = document.getElementById('chat-messages-container');
      // Capture scroll position BEFORE adding new items
      const previousScrollHeight = container.scrollHeight;
      const previousScrollTop = container.scrollTop;

      fetch(`/support/conversation/${conversationId}/history?cursor=${this.nextCursor}`)
              .then(response => response.json())
              .then(data => {
                if (data.messages && data.messages.length > 0) {
                  this.nextCursor = data.next_cursor;
                  this.hasMore = data.has_more;

                  data.messages.forEach(msg => {
                    const currentUserId = "{{.User.ID}}";
                    const isOwn = msg.sender_id === currentUserId;
                    this.appendMessageToUI({
                      content: msg.content,
                      sender_id: msg.sender_id,
                      created_at: msg.created_at,
                      id: msg.id
                    }, isOwn, true);
                  });

                  // === Scroll Restoration ===
                  const heightDifference = container.scrollHeight - previousScrollHeight;

                  if (previousScrollTop <= 0) {
                    // Chrome/Edge/Safari (Negative Scroll)
                    // In column-reverse, the bottom is 0. Adding items to the visual top (DOM end)
                    // does not change the distance of current items from the bottom.
                    // We must maintain the previous scrollTop value to stay in place.
                    container.scrollTop = previousScrollTop;
                  } else {
                    // Firefox (Positive Scroll)
                    // 0 is Top. Adding items pushes content down, so we must add height difference.
                    container.scrollTop = previousScrollTop + heightDifference;
                  }

                } else {
                  this.hasMore = false;
                }
              })
              .catch(err => console.error("Fetch History Error:", err))
              .finally(() => {
                // Short timeout to prevent rapid scroll firing
                setTimeout(() => {
                  this.isLoadingHistory = false;
                }, 100);
              });
    },

    sendMessage: function(conversationId, content) {
      if (!content.trim() || !this.ws || this.ws.readyState !== WebSocket.OPEN) return;

      const tempId = `local_${Date.now()}`;
      const payload = {
        type: 'text',
        content: content,
        conversation_id: conversationId,
        client_message_id: tempId
      };

      this.ws.send(JSON.stringify(payload));

      this.appendMessageToUI({
        content: content,
        sender_id: "{{.User.ID}}",
        created_at: new Date().toISOString(),
        id: tempId
      }, true, false);
    },

    handleIncomingMessage: function(msg) {
      if (msg.type === 'text') {
        if (msg.payload.conversation_id === this.activeConversationId) {
          const currentUserId = "{{.User.ID}}";
          const isOwn = msg.payload.sender_id === currentUserId;
          if (!isOwn) {
            this.appendMessageToUI(msg.payload, false, false);
          }
        }
      } else if (msg.type === 'system') {
        this.handleSystemMessage(msg);
      }
    },

    handleSystemMessage: function(msg) {
      if (msg.payload.conversation_id !== this.activeConversationId) return;
      const typingIndicator = document.getElementById('typing-indicator');
      if (!typingIndicator) return;

      if (msg.sub_type === 'typing_started') {
        typingIndicator.style.display = 'inline-block';
      } else if (msg.sub_type === 'typing_stopped') {
        typingIndicator.style.display = 'none';
      }
    },

    appendMessageToUI: function(msg, isOwn, isHistory) {
      const container = document.getElementById('chat-messages-container');
      if (!container) return;

      const div = document.createElement('div');
      div.className = `message-bubble ${isOwn ? 'mine' : 'theirs'}`;
      div.style.cssText = isOwn
              ? "align-self: flex-end; background: #06b6d4; color: white; border-bottom-right-radius: 2px; max-width: 70%; padding: 0.75rem 1rem; border-radius: 12px; margin-bottom: 0.5rem;"
              : "align-self: flex-start; background: rgba(255, 255, 255, 0.1); color: #e2e8f0; border-bottom-left-radius: 2px; max-width: 70%; padding: 0.75rem 1rem; border-radius: 12px; margin-bottom: 0.5rem;";

      let timeStr = "";
      try {
        timeStr = new Date(msg.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      } catch(e) {}

      div.innerHTML = `
            ${this.escapeHtml(msg.content)}
            <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 4px; text-align: right;">${timeStr}</div>
        `;

      if (isHistory) {
        // History: Append to end (Visual Top in column-reverse)
        container.appendChild(div);
      } else {
        // New Message: Prepend to start (Visual Bottom in column-reverse)
        container.prepend(div);
        // Force scroll to bottom (0) if user was near bottom
        if (Math.abs(container.scrollTop) < 50) {
          container.scrollTop = 0;
        }
      }
    },

    sendTyping: function(convId) {
      // Placeholder
    },

    startHeartbeat: function() {
      this.stopHeartbeat();
      this.heartbeatInterval = setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {}
      }, 30000);
    },

    stopHeartbeat: function() {
      if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
    },

    scrollToBottom: function() {
      const container = document.getElementById('chat-messages-container');
      if (container) {
        container.scrollTop = 0;
      }
    },

    showStatus: function(msg, type) {
      const el = document.getElementById('ws-status');
      if(el) {
        el.innerHTML = `<span style="background: ${type === 'success' ? 'green' : 'red'}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">${msg}</span>`;
        setTimeout(() => el.innerHTML = '', 3000);
      }
    },

    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    window.SupportChat.init();
  } else {
    document.addEventListener('DOMContentLoaded', () => {
      window.SupportChat.init();
    });
  }

  function switchSupportTab(selectedTab) {
    document.querySelectorAll('.support-tab').forEach(tab => tab.classList.remove('active'));
    selectedTab.classList.add('active');
    const filters = document.getElementById('my-conversations-filters');
    if (selectedTab.id === 'my-conversations-tab-btn') {
      filters.style.display = 'flex';
    } else {
      filters.style.display = 'none';
    }
  }
</script>

{{end}}