# ðŸ“š Quick Connect Chat SDK & API Reference (V2.4.1)

This document provides the definitive guide for integrating the Quick Connect chat widget, covering the client SDK architecture, required HTTP API calls, state management, and the full WebSocket protocol.

## 1\. Storage & State Management

The SDK maintains persistent state using the browser's `localStorage`. This allows it to reconnect and maintain the user's context, even after a page refresh.

| Storage Key | Purpose | Example Value |
| :--- | :--- | :--- |
| **`QC_TOKEN`** | The JWT token for authentication in all API/WebSocket calls. | `eyJhbGciOiJIUzI1NiI...` |
| **`QC_USER_STATE`** | Tracks user type. | `'guest'` or `'client'` |
| **`QC_CONVERSATION_ID`** | The unique ID of the current active conversation. **Must be retrieved via the `/conversations/active` API.** | `01KABWW5V95WFFDERJZCTDE2QQ` |

-----

## 2\. Initialization & Authentication Flow

The SDK initiates a defined flow to ensure the client is authenticated and has an active conversation context before connecting to the real-time server.

### Authentication Scenarios

| Scenario | Description | SDK Action | API Endpoint |
| :--- | :--- | :--- | :--- |
| **Guest User (Anonymous)** | No existing `QC_TOKEN` is found in storage. | The SDK automatically calls the Manager service to register a new guest user. | `POST {MANAGER_URL}/users/guest/register` |
| **Identified Client** | The host application injects a pre-authenticated token, or an existing valid token is found. | The SDK uses the token directly. (Manual integration via a host app endpoint not shown in SDK, but is supported). | N/A |

### Pre-Connection Step: Fetching Conversation Context

After securing a `QC_TOKEN`, the SDK **must** fetch the active conversation ID. This ID is mandatory for all WebSocket messages.

* **Endpoint:** `GET {CHAT_API_URL}/conversations/active`
* **Headers:** `Authorization: Bearer <QC_TOKEN>`
* **Action:** Stores the returned `id` in `QC_CONVERSATION_ID`.

-----

## 3\. HTTP API Endpoints

The SDK uses HTTP endpoints for authentication and fetching message history.

### Manager Service (Authentication & Profile)

| Method | Endpoint | Auth Required | Description |
| :--- | :--- | :--- | :--- |
| **POST** | `/users/guest/register` | No | Registers a new anonymous guest user. Returns `qc_token`. |
| **PUT** | `/users/guest/update` | **Yes** (JWT) | Updates the guest's profile (Name, Email). |

### Chat Service (Context & History)

| Method | Endpoint | Auth Required | Description |
| :--- | :--- | :--- | :--- |
| **GET** | `/conversations/active` | **Yes** (JWT) | Retrieves the current conversation ID and agent info. |
| **POST** | `/chats` | **Yes** (JWT) | **Fetches paginated chat history** using the Cursor-Based pagination strategy. |

#### Chat History Request Body (`POST /chats`)

| Field | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `conversation_id` | `string` | Yes | The ID of the conversation to fetch history for. |
| `pagination.cursor` | `string` | No | The cursor value of the oldest message received (or null for the first page). |
| `pagination.limit` | `integer` | No | Max number of messages to return (SDK uses **20**). |

-----

## 4\. WebSocket Connection & Protocol

### Connection Details

* **Client Endpoint:** `ws://{CHAT_URL}/chats/clients`

### Authentication via Protocol Header

Since standard browser WebSockets do not support custom headers, the JWT is sent securely within the `Sec-WebSocket-Protocol` header (as seen in the SDK code: `new WebSocket(wsUrl, [token])`).

-----

### 5\. Message Structures (Sending $\leftrightarrow$ Receiving)

All WebSocket traffic uses the generic JSON structure documented below.

#### 5.1. Sending Text Messages (Client $\rightarrow$ Server)

The client **must** include a `client_message_id` for **Optimistic UI reconciliation**.

```json
{
  "type": "text",
  "conversation_id": "01KAAWW5V95WFFDERJZCTDE2QQ",
  "content": "My message content.",
  "client_message_id": "temp_xyz_1678881234567" // Unique ID generated by client
}
```

#### 5.2. Receiving Messages (Server $\rightarrow$ Client)

The server broadcasts the confirmed message (or system event) to all participants.

```json
{
  "type": "string",           // "text" | "system"
  "sub_type": "string",       // e.g., "typing_started" (empty for text messages)
  "timestamp": "string",      // ISO 8601 Date Time
  "payload": { ... }          // Full Message Object or System Object
}
```

-----

### 6\. Optimistic UI & Reconciliation

The SDK implements a robust reconciliation strategy to provide an instant messaging experience:

1.  **On Send:** The SDK generates a `client_message_id`, adds the message to the UI immediately with a **"Pending"** status.
2.  **On Receive:** The server echoes the message back, including the `client_message_id` and the new database `id`.
3.  **Reconciliation:** The SDK searches its pending messages for the matching `client_message_id`, updates the message status to **"Sent/Confirmed"**, and replaces the temporary ID with the permanent database ID. **The SDK then skips rendering this message as a new incoming message.**

-----

### 7\. System Messages & Heartbeat (Typing Indicators)

System messages are ephemeral (not saved to the DB) and are used for real-time status updates.

#### A. Heartbeat (`sub_type: online`)

The client sends a system message every **50 seconds** (50000ms in code) to signal that the user is active on the conversation. This keeps the WebSocket connection alive and helps the agent side track client presence.

**Client $\rightarrow$ Server:**

```json
{
  "type": "system",
  "sub_type": "online",
  "conversation_id": "01K..."
}
```

#### B. Typing Indicators

| Event | Logic Rule (Source Code Verified) |
| :--- | :--- |
| **Sending (`typing_started`)** | Client sends this event **only if 5 seconds (5000ms) have passed** since the last `typing_started` event was sent. |
| **Sending (`typing_stopped`)** | Client sends this event when the input box is cleared or the message is sent (`sendMessage`). |
| **Receiving (Auto-hide)** | Upon receiving `typing_started` from an agent, the UI shows the typing indicator and sets an automatic **6-second (6000ms) timeout** to hide the indicator if no further `typing_started` or `typing_stopped` signal is received. |

**Sending/Receiving Structure Example (Typing Started):**

```json
{
  "type": "system",
  "sub_type": "typing_started",
  "conversation_id": "01K...",
  // When received: "payload": { "conversation_id": "...", "sender_id": "..." }
}
```